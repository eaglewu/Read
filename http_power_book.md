# HTTP权威指南

# 第一部分: Web的基础

# 4. 链接管理

## 4.1 TCP链接

### 4.1.1 TCP的可靠数据管道

输入 http://xxx.com:80的url请求

- 浏览器解析主机名
- 浏览器查询主机的IP地址(DNS) 202.43.378.3
- 浏览器获得端口号 80
- 浏览器发送 202.43.378.3端口80的连接
- 浏览器向服务器发送一条HTTP GET报文
- 浏览器从服务器读取HTTP 响应报文
- 浏览器关闭链接

### 4.1.2 TCP流是分段的、由IP分组传送

HTTP和HTTPS网络协议栈

- HTTP: 应用层
- TCP: 传输层
- IP: 网络层
- 网络接口: 数据链路层

HTTPS的

- HTTP: 应用层
- TSL or SSL: 安全层
- TCP: 传输层
- IP: 网络层
- 网络接口: 数据链路层

HTTP要发送一条报文时 会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输

TCP收到数据流之后 会将数据流砍成被称作段的小数据块 并将段封装在IP分组里 通过因特网进行传输

每个TCP段都是由IP分组承载 从一个IP地址发送到另一个IP地址的

每个IP分组中都包括

- 一个IP分组的首部(一般20字节): 源和目的IP地址、长度和一些标记
- 一个TCP端的首部(一般20字节): TCP端的首部包含了TCP端口号、TCP控制标记以及用于数据排序和完整性检查的一些数字值
- 一个TCP数据块(0/更多字节)

![IP分组的数据](./assets/WX20190708-230906.png)

### 4.1.4 用TCP套接字编程

|套接字API调用|描述|
|--|--|
|s = socket(<parameters>)| 创建一个新的、未命名、未关联的套接字|
|bind(s, <local IP:port>)| 向套接字赋一个本地端口号和接口|
|connect(s, <remote IP:port>)|创建一条连接本地套接字与远程主机及端口的连接|
|listenr(s, ...)| 标识一个本地套接字，使其可以合法接受连接|
|s2 = accept(s)| 等待某人建立一条到本地端口的连接|
|n = read(s, buffer, n)|尝试从套接字向缓冲区读取n个字节|
|n = write(s, buffer, n)| 尝试从缓冲区中向套接字写入n个字节|
|close(s)| 只关闭TCP连接的输入/输出端|
|shutdown(s, <side>)|只关闭TCP连接的输入或输出端|
|getsockopt(s, ...)| 读取某个内部套接字配置选项的值|
|setsockopt(s, ...)| 修改某个内部套接字配置选项的值|

![TCPAPI调用过程](./assets/QQ20190714-225057.jpg)

## 4.2 对TCP性能的考虑

### 4.2.1 HTTP事物的时延

- DNS解析时间
- 建立TCP的时间
- 等待服务器处理请求报文 服务器处理请求报文
- web服务器会送HTTP响应

### 4.2.2 性能聚焦区域

最常见的TCP相关时延

- TCP连接建立握手
- TCP慢启动阻塞控制
- 数据聚集的Nagle算法
- 用于捎带确认的TCP延迟确认算法
- TIME_WAIT时延和端口耗尽

### 4.2.3 TCO连接的握手时延

小的HTTP事物可能会在TCP建立上花费50%

### 4.2.4 延迟确认

TCP实现了自己的确认机制来确保数据的成功传输

每个TCP都有一个序列号和数据完整性的校验和, 每个段的接受者收到完好的段时, 都会向发送者会送小的确认分组

如果发送者没有在指定的窗口时间内收到确认信息, 发送者就任务分组已被破坏和损毁, 并重发数据

由于确认报文很小 所以TCP允许在发往相同方向的输出数据分组中对对其"捎带"

为了增加确认报文找到同向传输数据分组的可能性, 很多TCP栈都实现一个延迟算法

延迟算法会在一个特定的窗口时间(通过100~200ms) 内将输出确认存放在缓存区 

以寻找能够捎带它的输出数据分组

但是 HTTP具有双峰特征的 请求-应答 行为降低了捎带信息的可能 

当希望有相反反向回传的分组的时候 偏偏没那么多 通常延迟确认算法会引入相当大的延迟

但操作系统可以调整或禁止延迟确认算法

### 4.2.5 TCP慢启动

TCP连接会随着时间进行调整, 起初会限制连接的最大速度

如果数据成功传输 会随着时间 提高传输速度

这陈威TCP慢启动

用于防止因特网的突然过载和拥塞

TCP慢启动限制了一个TCP端点任意时刻可以传输的分组数

简单来说 每成功接受一个分组 发送端就有了发送另外两个端的权限

这个方式称为 打开拥塞窗口

因为这样的拥塞, 旧连接会比新连接块一些

这也是HTTP持久连接的优势之一

### 4.2.6 Nagle算法和TCP_NODELAY

每个TCP段至少装载了40个字节的标记和首部

Nagle算法 试图在发送一个分组之前 将大量TCP数据绑定在一起

Nagle算法鼓励发送全尺寸(LAN最大分组大约1500字节 因特网是几百字节)的段

只有当所有其他分组都被确认之后 Nagle算法才允许发送非全尺寸的分组

如果其他分组仍然在传输过程中 就将那部分数据线存起来

只有当挂起分组被确认 或者缓存够了一个全尺寸的发送数据时 才能发缓存数据

会引起性能问题

例如Nagle和延迟确认的交互存在问题

例如接受方启动了延迟算法延迟了100~200ms 那么发送方最少要等这段时间以后 才可以继续发送报文

HTTP可以设置TCP_NODELAY禁止nagle算法 但要确认会向TCP写入大块的数据 这样才不会生成一堆小分组

### 4.2.7 TIME_WAIT累积与端口耗尽

先引入一个概念 MSL(Maximum Segment Lifetime) 就是一个TCP包最大的存活时间

一个端在TCP断开连接后 为了防止延迟的无效消息被误认为是合法的

所以要在内存维护一个控制块 用来记录最近关闭连接的IP地址和端口号 然后进入TIME_WAIT状态

维持的时间为2MSL

一个TCP连接由源IP 源端口 目标IP 目标端口组成

在一台源服务器和一台目标服务器来说 能变的只有源端口

所以

关于TIME_WAIT的详解: https://blog.csdn.net/u010585120/article/details/80826999



# 第四部分 实体、编码和国际化

# 15. 实体和编码

## 15.6 传输编码和分块编码

内容编码和传输编码的对比

* 内容编码: 只是对报文的实体部分进行了可逆的编码.
* 传输编码: 作用在整个报文上,报文本身的结构发生变化.

### 15.6.1 可靠传输

传输报文主体可能会引发的问题

1. 未知尺寸: 假如服务器想在未知大小之前就无法开始传输,Content-length必须声明在数据前.
2. 安全性: 用传输编码将报文打乱,然后发送,但是SSL已经够安全了,所以这个不用考虑

### 15.6.2 Transfer-Encoding首部

最新的HTTP规范(2017-03-15)只定义了一种传输编码: 分块编码

请求头声明分块编码,告知服务器可以使用哪种传输编码拓展

TE: trailers, chunked(HTTP1.1强制默认)

在响应头声明分块编码,告知接收方使用了哪种传输编码

Transfer-Enconding: chunked

### 15.6.3 分块编码

分块传输响应DEMO

```bash
//HTTP响应
HTTP/1.1 200 OK<CR><LF>
Content-type: text/plain<CR><LF>
Transfer-encoding: chunked<CR><LF>
Trailer: Content-MD5<CR><LF>
<CR><LF>

//第一块
5<CR><LF>
01234<CR><LF>

//第二块
2<CR><LF>
01<CR><LF>

//最后一块
0<CR><LF>

//拖挂
Content-MD5: ****1112341***
```

> 1. 分块与持久连接

* 非持久连接: 本身就不需要知道长度,等着服务器关闭主体链接即可
* 持久连接: 静态内容,通过content-length获取长度,而动态内容,发送前无法知道主体的长度

分块编码规则

1. 每个分块包括两行,一行十六进制的长度值,第二行为数据
2. 两行都需要\r\n结尾
3. 最后一块的长度值必须为0,对应的分块数据没有内容

当你上传给服务器想使用分块传输时,因为服务器不会发送TE请求

所以要做好被服务器拒绝分块传输的准备(411 Length Required, 表名需要Content-length长度)

> 2. 分块报文的拖挂

拖挂用于在报文开始时无法确认的首部

除了Transfer-Encoding,Trailer以及Content-length首部外

其他HTTP首部都可以作为拖挂发送

## 15.8 验证码和新鲜度

### 15.8.1 新鲜度

服务器可以用这两个首部之一来提供这种信息

1. Expires(过期)
2. Cache-Control(缓存控制)

### 15.8.2 有条件的请求与验证码

请求类型             验证码          描述

If-Modified-Since   Last-Modified 如果前一条响应的Last-Modified首部中说明时间之后,资源的版本发生变化,就发送其副本

If-Unmodified-Since Last-Modified 仅在前一条响应的Last-Modified首部中说明的时间之后,资源的版本没有变化,才发送其副本

If-Match             Etag         如果实体的标记前一次响应收不中的Etag相同,就发送资源的副本

If-None-Match        Etag         如果实体的标记与前一次响应收不中的Etag不同,就发送该资源的副本

HTTP校验分为弱检验码(Last-Modified)和强验证码(Etag)

## 15.9 范围请求



